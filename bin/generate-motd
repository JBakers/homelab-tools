#!/bin/bash
set -euo pipefail

# Generate MOTD template for homelab services
# Author: J.Bakers
# Version: See VERSION file

# Colors
CYAN='\033[0;36m'
# Load shared constants (optional, used for detection rules)
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [[ -L "$SCRIPT_PATH" ]]; do
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ "$SCRIPT_PATH" != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
LIB_DIR="$(dirname "$SCRIPT_DIR")/lib"
if [[ -f "$LIB_DIR/constants.sh" ]]; then
    # shellcheck source=/dev/null
    source "$LIB_DIR/constants.sh"
fi
# Source menu helpers for choose_menu function
if [[ -f "$LIB_DIR/menu-helpers.sh" ]]; then
    # shellcheck source=/dev/null
    source "$LIB_DIR/menu-helpers.sh"
fi
# Source color definitions
if [[ -f "$LIB_DIR/colors.sh" ]]; then
    # shellcheck source=/dev/null
    source "$LIB_DIR/colors.sh"
fi

# Source service presets (AUDIT-16: Extracted from generate-motd)
if [[ -f "$LIB_DIR/service-presets.sh" ]]; then
    # shellcheck source=/dev/null
    source "$LIB_DIR/service-presets.sh"
fi

# Source port detection (P2: Smart Port Detection)
if [[ -f "$LIB_DIR/port-detection.sh" ]]; then
    # shellcheck source=/dev/null
    source "$LIB_DIR/port-detection.sh"
fi

# Source validators
if [[ -f "$LIB_DIR/validators.sh" ]]; then
    # shellcheck source=/dev/null
    source "$LIB_DIR/validators.sh"
fi

TEMPLATES_DIR="$HOME/.local/share/homelab-tools/templates"
CONFIG_FILE="/opt/homelab-tools/config.sh"

# Load config with validation
if [[ -f "$CONFIG_FILE" ]]; then
    # shellcheck source=/dev/null
    source "$CONFIG_FILE"
    
    # Validate config values to prevent code injection
    if [[ -n "${DOMAIN_SUFFIX:-}" ]] && ! [[ "$DOMAIN_SUFFIX" =~ ^[a-zA-Z0-9._-]*$ ]]; then
        echo -e "${RED}âœ— Error: Invalid DOMAIN_SUFFIX in config${RESET}"
        exit 1
    fi
    
    if [[ -n "${IP_METHOD:-}" ]] && [[ "$IP_METHOD" != "hostname" && "$IP_METHOD" != "ip" ]]; then
        echo -e "${RED}âœ— Error: Invalid IP_METHOD in config (must be 'hostname' or 'ip')${RESET}"
        exit 1
    fi
else
    # Defaults
    export DOMAIN_SUFFIX=""
    export IP_METHOD="ip"
fi

show_help() {
    echo -e "${BOLD}${CYAN}generate-motd - Generate MOTD template${RESET}"
    echo ""
    echo -e "${BOLD}USAGE:${RESET}"
    echo "  generate-motd <service-name>"
    echo ""
    echo -e "${BOLD}DESCRIPTION:${RESET}"
    echo "  Generates a dynamic MOTD template for a homelab service."
    echo "  Template is saved in ~/homelab-tools/templates/"
    echo ""
    echo -e "${BOLD}INTERACTIVE:${RESET}"
    echo "  The script will ask for:"
    echo "  - Service name (e.g., Pi-hole, Home Assistant)"
    echo "  - Description (e.g., Media Server)"
    echo "  - Whether there's a Web UI (y/n)"
    echo "  - Port number (if Web UI)"
    echo ""
    echo -e "${BOLD}EXAMPLE:${RESET}"
    echo -e "  ${GREEN}generate-motd jellyfin${RESET}"
    echo ""
    echo "  The script will then ask:"
    echo "    Service name: Jellyfin"
    echo "    Description: Media Server"
    echo "    Web UI? (y/n): y"
    echo "    Port: 8096"
    echo ""
    echo -e "${BOLD}NOTE:${RESET}"
    echo -e "  The MOTD is ${YELLOW}dynamically${RESET} generated on each login, so"
    echo "  information like uptime and versions are always current."
    echo ""
}

if [[ "${1:-}" == "--help" ]] || [[ "${1:-}" == "-h" ]]; then
    show_help
    exit 0
fi

SERVICE=${1:-}

if [[ -z "$SERVICE" ]]; then
    echo -e "${RED}âœ— Error: No service name provided${RESET}"
    echo -e "  Usage: ${GREEN}generate-motd <service-name>${RESET}"
    echo -e "  Example: ${GREEN}generate-motd pihole${RESET}"
    echo -e "  Or: ${CYAN}generate-motd --help${RESET} for more information"
    exit 1
fi

# Validate service name to prevent command injection
if [[ ! "$SERVICE" =~ ^[a-zA-Z0-9._-]+$ ]]; then
    echo -e "${RED}âœ— Error: Invalid service name${RESET}"
    echo -e "  Only letters, digits, dots, underscores and hyphens are allowed"
    echo -e "  Example: ${GREEN}generate-motd pihole${RESET}"
    exit 1
fi

# Check if system is unsupported (before detection logic)
SERVICE_LOWER=$(echo "$SERVICE" | tr '[:upper:]' '[:lower:]')
for unsupported in "${UNSUPPORTED_SYSTEMS[@]}"; do
    if [[ "$SERVICE_LOWER" == "$unsupported" ]]; then
        echo -e "${YELLOW}âš ${RESET} ${BOLD}$SERVICE${RESET} doesn't support MOTD"
        echo ""
        echo -e "${BOLD}Reason:${RESET}"
        case "$unsupported" in
            homeassistant|hass|ha)
                echo -e "  Home Assistant runs in Docker without system access"
                echo -e "  Use the web UI: ${CYAN}http://${SERVICE}${DOMAIN_SUFFIX}:8123${RESET}"
                ;;
            truenas)
                echo -e "  TrueNAS is a FreeBSD appliance (not Linux)"
                echo -e "  Use the web UI: ${CYAN}https://${SERVICE}${DOMAIN_SUFFIX}${RESET}"
                ;;
            pfsense|opnsense)
                echo -e "  Firewall appliances don't support custom MOTD"
                echo -e "  Use the web UI: ${CYAN}https://${SERVICE}${DOMAIN_SUFFIX}${RESET}"
                ;;
            windows|win)
                echo -e "  Windows systems don't use MOTD"
                echo -e "  Use RDP to connect"
                ;;
            unraid)
                echo -e "  Unraid uses a different MOTD system"
                echo -e "  Use the web UI: ${CYAN}http://${SERVICE}${DOMAIN_SUFFIX}${RESET}"
                ;;
            synology|nas|qnap)
                echo -e "  NAS systems have proprietary operating systems"
                echo -e "  Use the web UI: ${CYAN}http://${SERVICE}${DOMAIN_SUFFIX}:5000${RESET}"
                ;;
        esac
        echo ""
        exit 0
    fi
done

# ============================================================
# SERVICE AUTO-DETECTION (using lib/service-presets.sh)
# ============================================================
detect_service_preset "$SERVICE"

# Map globals to local variables for backward compatibility
service_name="$HLT_SERVICE_NAME"
description="$HLT_SERVICE_DESC"
has_webui="$HLT_HAS_WEBUI"
webui_port="$HLT_WEBUI_PORT"

# ============================================================
# SMART PORT DETECTION (P2: check config, docker, listening ports)
# ============================================================
# Initialize port detection (creates config dir if needed)
if type init_port_detection &>/dev/null; then
    init_port_detection
fi

# Try smart port detection (config file overrides, docker, listening ports)
if type detect_port &>/dev/null; then
    if detect_port "$SERVICE" "$SERVICE"; then
        # Only use detected port if different from default and source is not "default"
        if [[ "$HLT_PORT_SOURCE" != "default" && -n "$HLT_DETECTED_PORT" ]]; then
            webui_port="$HLT_DETECTED_PORT"
            # Also set has_webui to y if we detected a port
            [[ -n "$webui_port" ]] && has_webui="y"
        fi
    fi
fi

# ============================================================
# NON-INTERACTIVE MODE
# ============================================================
# Non-interactive mode: if stdin is piped, use detected values or read from stdin
if [[ ! -t 0 ]]; then
    mkdir -p "$TEMPLATES_DIR"
    template_path="$TEMPLATES_DIR/$SERVICE.sh"
    
    # Use detected values as defaults
    webui_flag="$has_webui"
    # webui_port already set from detection above
    
    # Read stdin to override if provided: y/n and port/url
    if IFS= read -r webui_flag_input; then
        if [[ -n "$webui_flag_input" ]]; then
            webui_flag="$webui_flag_input"
        fi
    fi
    if IFS= read -r webui_port_input; then
        if [[ -n "$webui_port_input" ]]; then
            webui_port="$webui_port_input"
        fi
    fi
    
    # Build optional web URL using detected or provided values
    web_url=""
    if [[ "$webui_flag" =~ ^[Yy]$ ]] && [[ -n "$webui_port" ]]; then
        web_url="http://${SERVICE}${DOMAIN_SUFFIX}:${webui_port}"
    elif [[ "$webui_flag" =~ ^[Yy]$ ]]; then
        web_url="http://${SERVICE}${DOMAIN_SUFFIX}"
    fi
    # Genereer ASCII art als beschikbaar (non-interactive kan style kiezen via stdin)
    ascii_rendering=""
    if [[ "$webui_flag" =~ ^[Yy]$ ]] && command -v toilet &> /dev/null; then
        # Non-interactive: standaard Rainbow Future als toilet beschikbaar
        ascii_rendering=$(toilet -f future -F gay "$service_name" 2>/dev/null || echo "")
        if [[ -z "$ascii_rendering" ]]; then
            ascii_rendering=""
        fi
    fi
    
    # Build template with ASCII art if available
    cat > "$template_path" << 'EOF'
#!/bin/bash
# === HLT-MOTD-START ===
# Generated by Homelab Tools (https://github.com/JBakers/homelab-tools)
# Do not edit between HLT-MOTD-START and HLT-MOTD-END markers
# MOTD - Complete template

NC='\033[0m'
CYAN='\033[0;96m'
GREEN='\033[0;92m'
YELLOW='\033[1;33m'
MAGENTA='\033[0;35m'
RED='\033[0;91m'
BOLD='\033[1m'
UNDERLINE='\033[4m'
NC='\033[0m'

echo ""
echo -e "${YELLOW}========================================${NC}"
echo -e "${CYAN}${BOLD}SERVICE_NAME_PLACEHOLDER${NC}"
echo -e "${MAGENTA}DESCRIPTION_PLACEHOLDER${NC}"
echo -e "${MAGENTA}by J.Bakers${NC}"
echo -e "${YELLOW}========================================${NC}"
echo ""
echo -e "${GREEN}${BOLD}ðŸ“Š System Information:${NC}"
echo ""
echo -e "  ${YELLOW}ðŸ–¥ï¸  Hostname:${NC}    $(hostname)"
echo -e "  ${YELLOW}ðŸŒ IP Address:${NC}  $(hostname -I | awk '{print $1}')"
echo -e "  ${YELLOW}â±ï¸  Uptime:${NC}      $(uptime -p)"
EOF
    
    # Add Web UI if specified
    if [[ -n "$web_url" ]]; then
        echo "echo -e \"  \${YELLOW}ðŸ”— Web UI:\${NC}      \${CYAN}$web_url\${NC}\"" >> "$template_path"
    fi
    
    # Add closing marker
    cat >> "$template_path" << 'EOF'
echo ""
echo -e "${YELLOW}========================================${NC}"
echo ""
# === HLT-MOTD-END ===
EOF
    
    # Replace placeholders (use detected service_name)
    service_escaped=$(echo "$service_name" | sed 's/[\/&]/\\&/g')
    sed -i "s/SERVICE_NAME_PLACEHOLDER/$service_escaped/g" "$template_path"
    sed -i "s/DESCRIPTION_PLACEHOLDER/$description/g" "$template_path"
    
    chmod +x "$template_path"
    echo -e "${GREEN}âœ“${RESET} Template created: ${CYAN}$template_path${RESET}"
    exit 0
fi

# Check if system is unsupported (already done above, this is duplicate - remove this entire block)

mkdir -p "$TEMPLATES_DIR"

echo -e "${BOLD}${CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
echo -e "â•‘         ðŸ“ MOTD Generator                                 â•‘"
echo -e "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
echo ""
echo -e "${BOLD}Service: ${GREEN}$SERVICE${RESET}"
echo ""

# Service detection already done above (skip duplicate case statement here)

echo -e "${GREEN}âœ“${RESET} Auto-detected: ${CYAN}$service_name - $description${RESET}"
if [[ "$has_webui" == "y" ]]; then
    echo -e "${GREEN}âœ“${RESET} Web UI: ${CYAN}$webui_port${RESET}"
fi
echo ""

# Ask for confirmation or override using arrow menu

echo -e "${GREEN}âœ“${RESET} Auto-detected: ${CYAN}$service_name - $description${RESET}"
if [[ "$has_webui" == "y" ]]; then
    echo -e "${GREEN}âœ“${RESET} Web UI: ${CYAN}$webui_port${RESET}"
fi
echo ""

# Ask for confirmation or override using arrow menu
choose_menu "Continue with these settings?" \
    "Yes, generate MOTD|Use auto-detected settings" \
    "Customize|Edit service name, description, Web UI" \
    "Cancel|Abort generation"

case $HLT_MENU_RESULT in
    0)
        # Continue with defaults
        ;;
    1)
        # Customize
        echo ""
        echo -e "${BOLD}${CYAN}Customize Settings${RESET}"
        echo ""
        read -r -p "$(echo -e "${CYAN}Service name (for ASCII art) [${service_name}]:${RESET} ")" custom_name
        [[ -n "$custom_name" ]] && service_name="$custom_name"
        
        read -r -p "$(echo -e "${CYAN}Description [${description}]:${RESET} ")" custom_desc
        [[ -n "$custom_desc" ]] && description="$custom_desc"
        
        # Web UI selection with arrow menu
        choose_menu "Has Web UI?" \
            "Yes|Service has a web interface" \
            "No|No web interface"
        
        if [[ $HLT_MENU_RESULT -eq 0 ]]; then
            has_webui="y"
            read -r -p "$(echo -e "${CYAN}Port or URL [${webui_port:-8080}]:${RESET} ")" custom_port
            [[ -n "$custom_port" ]] && webui_port="$custom_port"
            [[ -z "$webui_port" ]] && webui_port="8080"
        else
            has_webui="n"
            webui_port=""
        fi
        ;;
    -1|2|*)
        echo -e "${YELLOW}Cancelled${RESET}"
        exit 0
        ;;
esac

echo ""
echo -e "${YELLOW}â†’${RESET} Choosing ASCII art style..."
echo ""

# Function to show ASCII preview
show_ascii_preview() {
    local text="$1"
    local font="$2"
    local filter="$3"
    
    if command -v toilet &> /dev/null; then
        if [[ -n "$filter" ]]; then
            toilet -f "$font" -F "$filter" "$text" 2>/dev/null
        else
            toilet -f "$font" "$text" 2>/dev/null
        fi
    elif command -v figlet &> /dev/null; then
        figlet "$text" 2>/dev/null
    else
        echo "=== $text ==="
    fi
}

# Show available styles
echo -e "${BOLD}Available MOTD styles:${RESET}"
echo ""

if command -v toilet &> /dev/null; then
    while true; do
        choose_menu "Choose MOTD Style" \
            "Clean & Functional|No ASCII - Clean & Informative" \
            "Rainbow Future|Colorful, modern" \
            "Rainbow Standard|Colorful, classic" \
            "Mono Future|Black & white, modern" \
            "Big Mono|Large, bold" \
            "Small/Smblock|Small, compact" \
            "PREVIEW|Show all styles"
        
        choice_idx=$HLT_MENU_RESULT
        
        # Check if cancelled
        if [[ $choice_idx -eq -1 ]]; then
            echo -e "${YELLOW}Cancelled${RESET}"
            exit 0
        fi
        
        # Handle preview (last option)
        if [[ $choice_idx -eq 6 ]]; then
            clear
            echo -e "${BOLD}${CYAN}ASCII Art Preview - \"$service_name\"${RESET}"
            echo ""

            echo -e "${CYAN}2) Rainbow Future:${RESET}"
            show_ascii_preview "$service_name" "future" "gay"
            echo ""

            echo -e "${CYAN}3) Rainbow Standard:${RESET}"
            show_ascii_preview "$service_name" "standard" "gay"
            echo ""

            echo -e "${CYAN}4) Mono Future:${RESET}"
            show_ascii_preview "$service_name" "future" ""
            echo ""

            echo -e "${CYAN}5) Big Mono:${RESET}"
            show_ascii_preview "$service_name" "bigmono9" ""
            echo ""

            echo -e "${CYAN}6) Small/Smblock:${RESET}"
            show_ascii_preview "$service_name" "smblock" ""
            echo ""

            read -p "$(echo -e ${GREEN}Press Enter to continue...${RESET} )"
            continue
        fi
        
        # Valid style selected (convert 0-based to 1-based for ASCII mapping)
        style_choice=$((choice_idx + 1))
        break
    done
else
    echo -e "${YELLOW}âš  Toilet not installed - ASCII art not available${RESET}"
    echo -e "  For ASCII art: ${GREEN}sudo apt install toilet toilet-fonts${RESET}"
    style_choice="1"
fi

# Determine font and filter based on choice
case "$style_choice" in
    1|"")
        # Clean & Functional - no ASCII art
        ascii_font="none"
        ascii_filter=""
        echo -e "${GREEN}âœ“${RESET} Selected: Clean & Functional (no ASCII)"
        ;;
    2)
        ascii_font="future"
        ascii_filter="gay"
        echo -e "${GREEN}âœ“${RESET} Selected: Rainbow Future"
        ;;
    3)
        ascii_font="standard"
        ascii_filter="gay"
        echo -e "${GREEN}âœ“${RESET} Selected: Rainbow Standard"
        ;;
    4)
        ascii_font="future"
        ascii_filter=""
        echo -e "${GREEN}âœ“${RESET} Selected: Mono Future"
        ;;
    5)
        ascii_font="bigmono9"
        ascii_filter=""
        echo -e "${GREEN}âœ“${RESET} Selected: Big Mono"
        ;;
    6)
        ascii_font="smblock"
        ascii_filter=""
        echo -e "${GREEN}âœ“${RESET} Selected: Small/Smblock"
        ;;
    *)
        # Default to clean functional
        ascii_font="none"
        ascii_filter=""
        echo -e "${YELLOW}âš ${RESET} Invalid choice, using Clean & Functional"
        ;;
esac

# Genereer ASCII art LOKAAL
rainbow_art=""
if [[ "$ascii_font" == "none" ]]; then
    # Clean & Functional - geen ASCII art, alleen service naam
    rainbow_art=""
elif [[ "$ascii_font" == "basic" ]]; then
    # Fallback: figlet of plain text
    if command -v figlet &> /dev/null; then
        rainbow_art=$(figlet -c "$service_name" 2>/dev/null)
    else
        rainbow_art=$(printf "%40s\n" "=== $service_name ===")
    fi
else
    # Gebruik gekozen toilet font/filter
    if [[ -n "$ascii_filter" ]]; then
        rainbow_art=$(toilet -f "$ascii_font" -F "$ascii_filter" "$service_name" 2>/dev/null)
    else
        rainbow_art=$(toilet -f "$ascii_font" "$service_name" 2>/dev/null)
    fi

    # Fallback if font doesn't work
    if [[ -z "$rainbow_art" ]]; then
        rainbow_art=$(toilet -f standard -F gay "$service_name" 2>/dev/null)
        echo -e "${YELLOW}âš ${RESET} Font not available, using standard"
    fi
fi

# Determine which version commands are needed
version_check=""
case "$SERVICE" in
    pihole)
        version_check="PIHOLE_VERSION=\$(sudo pihole -v 2>/dev/null | grep 'Pi-hole' | awk '{print \$3}')"
        ;;
    docker|portainer|jellyfin|sonarr|radarr|prowlarr|plex)
        version_check="DOCKER_VERSION=\$(docker --version 2>/dev/null | awk '{print \$3}' | tr -d ',')"
        ;;
    homeassistant|hass)
        version_check="HASS_VERSION=\$(docker exec homeassistant cat /config/.HA_VERSION 2>/dev/null)"
        ;;
esac

# Genereer de template - start met header en HLT marker
cat > "$TEMPLATES_DIR/$SERVICE.sh" << 'TEMPLATE_START'
#!/bin/bash
# === HLT-MOTD-START ===
# Generated by Homelab Tools (https://github.com/JBakers/homelab-tools)
# Do not edit between HLT-MOTD-START and HLT-MOTD-END markers
# MOTD
# Kleuren
CYAN='\033[0;96m'
GREEN='\033[0;92m'
YELLOW='\033[0;93m'
# BLUE removed - using CYAN instead
MAGENTA='\033[0;95m'
RED='\033[0;91m'
BOLD='\033[1m'
UNDERLINE='\033[4m'
NC='\033[0m'

# Get current information
HOSTNAME=$(hostname)

# Try hostname -I first (simple), fallback to ip route (reliable in containers)
IP_ADDRESS=$(hostname -I 2>/dev/null | awk '{print $1}')
if [[ -z "$IP_ADDRESS" ]]; then
    IP_ADDRESS=$(ip route get 1.1.1.1 2>/dev/null | awk '{print $7}')
fi
if [[ -z "$IP_ADDRESS" ]]; then
    IP_ADDRESS="N/A"
fi

UPTIME=$(uptime -p | sed 's/up //')

VERSION_CHECK_PLACEHOLDER
TEMPLATE_START

# Add ASCII art or clean header - depending on selection
if [[ "$ascii_font" == "none" ]]; then
    # Clean & Functional - geen ASCII art
    cat >> "$TEMPLATES_DIR/$SERVICE.sh" << 'TEMPLATE_CLEAN'

echo ""
echo -e "${CYAN}==========================================${NC}"
echo -e "  ${CYAN}${BOLD}SERVICE_NAME_PLACEHOLDER${NC}"
echo -e "  ${MAGENTA}DESCRIPTION_PLACEHOLDER${NC}"
echo -e "  ${MAGENTA}by J.Bakers${NC}"
echo -e "${CYAN}==========================================${NC}"
echo ""
echo -e "${GREEN}${BOLD}ðŸ“Š System Information:${NC}"
echo ""
echo -e "  ${YELLOW}ðŸ–¥ï¸  Hostname:${NC}    $HOSTNAME"
echo -e "  ${YELLOW}ðŸŒ IP Address:${NC}  $IP_ADDRESS"
echo -e "  ${YELLOW}â±ï¸  Uptime:${NC}      $UPTIME"
TEMPLATE_CLEAN
else
    # ASCII art versie
    cat >> "$TEMPLATES_DIR/$SERVICE.sh" << 'TEMPLATE_ASCII_START'

# ASCII Art (met lichte indent)
echo ""
while IFS= read -r line; do
    printf "     %s\n" "$line"
done << 'ASCII_ART'
TEMPLATE_ASCII_START

    # Add ASCII art as a heredoc block (preserves all ANSI codes)
    echo "$rainbow_art" >> "$TEMPLATES_DIR/$SERVICE.sh"

    # Sluit de ASCII art heredoc af en ga verder met de template
    cat >> "$TEMPLATES_DIR/$SERVICE.sh" << 'TEMPLATE_ASCII_MIDDLE'
ASCII_ART
echo ""
echo -e "        ${CYAN}DESCRIPTION_PLACEHOLDER${NC}"
echo -e "           ${MAGENTA}by J.Bakers${NC}"
echo ""
echo -e "${CYAN}==========================================${NC}"
printf "%7s" ""
echo -e "${GREEN}${BOLD}${UNDERLINE}ðŸ“Š System Information:${NC}"
echo ""
echo -e "  ${YELLOW}ðŸ–¥ï¸  Hostname:${NC}    $HOSTNAME"
echo -e "  ${YELLOW}ðŸŒ IP Address:${NC}  $IP_ADDRESS"
echo -e "  ${YELLOW}â±ï¸  Uptime:${NC}      $UPTIME"
TEMPLATE_ASCII_MIDDLE
fi

# Add version checks if applicable
if [[ -n "$version_check" ]]; then
    cat >> "$TEMPLATES_DIR/$SERVICE.sh" << VERSION_SECTION
$version_check
VERSION_SECTION
else
    # Verwijder placeholder als er geen version check is
    sed -i '/VERSION_CHECK_PLACEHOLDER/d' "$TEMPLATES_DIR/$SERVICE.sh"
fi

# Add version display
cat >> "$TEMPLATES_DIR/$SERVICE.sh" << 'VERSION_DISPLAY'
# Version info (if available)
if [[ -n "$PIHOLE_VERSION" ]]; then
    echo -e "  ${YELLOW}ðŸ›¡ï¸  Pi-hole:${NC}     $PIHOLE_VERSION"
fi
if [[ -n "$DOCKER_VERSION" ]]; then
    echo -e "  ${YELLOW}ðŸ‹ Docker:${NC}      $DOCKER_VERSION"
fi
if [[ -n "$HASS_VERSION" ]]; then
    echo -e "  ${YELLOW}ðŸ  Home Assistant:${NC} $HASS_VERSION"
fi
VERSION_DISPLAY

# Vervang description en service name placeholders (escape special characters for sed)
description_escaped=$(echo "$description" | sed 's/[\/&]/\\&/g')
service_name_escaped=$(echo "$service_name" | sed 's/[\/&]/\\&/g')
sed -i "s/DESCRIPTION_PLACEHOLDER/$description_escaped/g" "$TEMPLATES_DIR/$SERVICE.sh"
sed -i "s/SERVICE_NAME_PLACEHOLDER/$service_name_escaped/g" "$TEMPLATES_DIR/$SERVICE.sh"

# Add Web UI if needed
if [[ -n "$webui_port" ]]; then
    # Check of het een URL of poort is
    if [[ "$webui_port" =~ ^https?:// ]]; then
        web_url="$webui_port"
    else
        # Gebruik hostname met domein suffix
        hostname_var="\$(hostname -s)"
        
        # Determine protocol (Proxmox and PBS use HTTPS)
        if [[ "$SERVICE" =~ ^(proxmox|pbs) ]]; then
            protocol="https"
        else
            protocol="http"
        fi
        
        web_url="${protocol}://${hostname_var}${DOMAIN_SUFFIX}:${webui_port}"
    fi
    
    cat >> "$TEMPLATES_DIR/$SERVICE.sh" << WEBUI_SECTION
echo -e "  \${YELLOW}ðŸ”— Web UI:\${NC}      \${CYAN}$web_url\${NC}"
WEBUI_SECTION
fi

# Sluit af met HLT end marker
cat >> "$TEMPLATES_DIR/$SERVICE.sh" << 'TEMPLATE_END'
echo ""
echo -e "${CYAN}==========================================${NC}"
echo ""
# === HLT-MOTD-END ===
TEMPLATE_END

chmod +x "$TEMPLATES_DIR/$SERVICE.sh"

echo ""
echo -e "${GREEN}âœ“ Template successfully created!${RESET}"
echo -e "  Location: ${CYAN}$TEMPLATES_DIR/$SERVICE.sh${RESET}"
echo ""

# Ask if deploy immediately using arrow menu
choose_menu "Deploy now?" \
    "Yes, deploy via SSH|Deploy template to $SERVICE" \
    "No, later|Save template, deploy manually later"

case $HLT_MENU_RESULT in
    0)
        # Deploy now
        echo ""
        if command -v deploy-motd &> /dev/null; then
            deploy-motd "$SERVICE"
        else
            echo -e "${RED}âœ— deploy-motd command not found${RESET}"
            echo -e "  Run manually: ${GREEN}deploy-motd $SERVICE${RESET}"
        fi
        ;;
    -1|1|*)
        # Skip deployment
        echo ""
        echo -e "${YELLOW}Next step:${RESET}"
        echo -e "  ${GREEN}deploy-motd $SERVICE${RESET}"
        echo ""
        ;;
esac
